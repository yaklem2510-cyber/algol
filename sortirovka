1. Блочная (корзинная) сортировка
Определение:
Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.

Код программы:

python
def bucket_sort(arr):
    # Проверка на пустой массив
    if len(arr) == 0:
        return arr
    
    # Определение минимального и максимального значений
    min_val, max_val = min(arr), max(arr)
    
    # Количество корзин равно длине массива
    bucket_count = len(arr)
    buckets = [[] for _ in range(bucket_count)]
    
    # Распределение элементов по корзинам
    for num in arr:
        # Вычисление индекса корзины для текущего числа
        index = int((num - min_val) / (max_val - min_val + 1) * bucket_count)
        buckets[index].append(num)
    
    # Сбор результатов
    result = []
    for bucket in buckets:
        # Сортировка каждой корзины (можно использовать любой алгоритм)
        result.extend(sorted(bucket))  # здесь используется встроенная сортировка
    
    return result

# Пример использования
arr = [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
print("Исходный массив:", arr)
print("Отсортированный массив:", bucket_sort(arr))
Принцип работы:
Алгоритм работает в несколько этапов. Сначала определяются граничные значения массива - минимальное и максимальное. На основе этих значений создаются корзины (блоки), каждая из которых отвечает за определенный диапазон чисел. Элементы массива распределяются по корзинам в соответствии с их значениями - каждый элемент попадает в ту корзину, диапазону которой соответствует его значение. После распределения каждая корзина сортируется независимо от других - это можно делать любым алгоритмом сортировки, в данном примере используется встроенная сортировка Python. На заключительном этапе отсортированные корзины объединяются в единый массив, который и является результатом работы алгоритма.

Временная сложность:
O(
n
+
k
)
O(n+k)

Объяснение временной сложности:
В лучшем случае, когда элементы равномерно распределены по корзинам, сложность составляет 
O
(
n
)
O(n), где 
n
n - количество элементов. Однако в общем случае сложность зависит от алгоритма сортировки внутри корзин (
k
k). Если использовать сортировку вставками для небольших корзин, средняя сложность будет 
O
(
n
+
n
2
k
+
k
)
O(n+ 
k
n 
2
 
​
 +k), но при оптимальном выборе количества корзин и равномерном распределении данных достигается 
O
(
n
)
O(n).

2. Блинная сортировка
Определение:
Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.

Код программы:

python
def pancake_sort(arr):
    n = len(arr)
    
    # Проходим от конца массива к началу
    for i in range(n, 0, -1):
        # Находим индекс максимального элемента в неотсортированной части
        max_idx = arr.index(max(arr[:i]))
        
        # Если максимальный элемент не на своем месте
        if max_idx != i - 1:
            # Переворачиваем часть массива до максимального элемента,
            # чтобы переместить его в начало
            arr[:max_idx + 1] = reversed(arr[:max_idx + 1])
            
            # Переворачиваем неотсортированную часть,
            # чтобы переместить максимальный элемент на правильную позицию
            arr[:i] = reversed(arr[:i])
    
    return arr

# Пример использования
arr = [3, 1, 4, 2, 6, 5]
print("Исходный массив:", arr)
print("Отсортированный массив:", pancake_sort(arr.copy()))
Принцип работы:
Алгоритм имитирует процесс переворачивания стопки блинов. На каждом шаге находится максимальный элемент в неотсортированной части массива. Если этот элемент уже находится на своей конечной позиции, алгоритм переходит к следующему шагу. Если нет, выполняется два переворота: сначала переворачивается часть массива от начала до максимального элемента, чтобы переместить его в начало массива, затем переворачивается вся неотсортированная часть, чтобы установить максимальный элемент на его окончательную позицию. Этот процесс повторяется для всех элементов массива.

Временная сложность:
O
(
n
2
)
O(n 
2
 )

Объяснение временной сложности:
Для каждого из 
n
n элементов выполняется поиск максимального элемента (
O
(
n
)
O(n)) и два переворота подмассивов (каждый 
O
(
n
)
O(n) в худшем случае). Таким образом, общая сложность составляет 
O
(
n
×
(
n
+
n
)
)
=
O
(
n
2
)
O(n×(n+n))=O(n 
2
 ). В худшем случае требуется до 
2
n
−
3
2n−3 переворотов.

3. Сортировка бусинами (гравитационная)
Определение:
Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году.

Код программы:

python
def bead_sort(arr):
    # Проверка на неотрицательные числа
    if not arr or min(arr) < 0:
        raise ValueError("Массив должен содержать неотрицательные числа.")
    
    # Находим максимальное значение
    max_val = max(arr)
    n = len(arr)
    
    # Создаем матрицу бусин (1 - бусина есть, 0 - нет)
    beads = [[0] * max_val for _ in range(n)]
    
    # Размещаем бусины согласно числам в массиве
    for i, num in enumerate(arr):
        beads[i][:num] = [1] * num
    
    # Моделируем "падение" бусин под действием гравитации
    for j in range(max_val):
        # Считаем количество бусин в каждом столбце
        count = sum(beads[i][j] for i in range(n))
        
        # Перераспределяем бусины - они "падают" вниз
        for i in range(n - 1, n - count - 1, -1):
            beads[i][j] = 1
        for i in range(n - count - 1, -1, -1):
            beads[i][j] = 0
    
    # Восстанавливаем отсортированный массив из бусин
    return [sum(row) for row in beads]

# Пример использования
arr = [3, 1, 4, 2]
print("Исходный массив:", arr)
print("Отсортированный массив:", bead_sort(arr))
Принцип работы:
Алгоритм визуализирует числа как столбцы бусин на вертикальных стержнях. Каждое число представляется количеством бусин на соответствующем стержне. Под действием "гравитации" бусины падают вниз - алгоритм последовательно обрабатывает каждый уровень (столбец) и перераспределяет бусины таким образом, что в нижних позициях оказывается больше бусин, чем в верхних. После обработки всех уровней бусины в нижних позициях образуют отсортированную последовательность.

Временная сложность:
O
(
n
⋅
m
)
O(n⋅m)

Объяснение временной сложности:
Сложность зависит от двух факторов: 
n
n (количество элементов) и 
m
m (максимальное значение в массиве). Алгоритм должен обработать матрицу размером 
n
×
m
n×m, выполняя операции для каждой ячейки. В худшем случае, когда 
m
m значительно больше 
n
n, сложность может быть высокой, но для целых чисел с ограниченным диапазоном алгоритм может быть достаточно эффективным.

4. Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через 
n
n
​
 ), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.

Код программы:

python
import math

def jump_search(arr, target):
    n = len(arr)
    if n == 0:
        return -1
    
    # Определяем размер прыжка
    step = int(math.sqrt(n))
    prev = 0
    
    # Прыгаем вперед, пока не найдем блок, содержащий целевой элемент
    while arr[min(step, n) - 1] < target:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n:
            return -1
    
    # Выполняем линейный поиск в найденном блоке
    for i in range(prev, min(step, n)):
        if arr[i] == target:
            return i
    
    return -1

# Пример использования
arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
target = 34
print(f"Массив: {arr}")
print(f"Поиск элемента {target}: индекс {jump_search(arr, target)}")
Принцип работы:
Алгоритм работает в два этапа. На первом этапе он выполняет "прыжки" фиксированного размера (обычно 
n
n
​
 ) по отсортированному массиву, сравнивая последний элемент каждого блока с искомым значением. Когда находится блок, где последний элемент больше или равен целевому значению, а предыдущий блок меньше целевого значения, алгоритм переходит ко второму этапу. На втором этапе выполняется линейный поиск внутри найденного блока для точного определения позиции элемента.

Временная сложность:
O
(
n
)
O( 
n
​
 )

Объяснение временной сложности:
Алгоритм совершает не более 
n
m
m
n
​
  прыжков, где 
m
=
n
m= 
n
​
 , и затем выполняет линейный поиск в блоке размером 
m
m. Таким образом, общее количество сравнений составляет 
O
(
n
m
+
m
)
O( 
m
n
​
 +m). При 
m
=
n
m= 
n
​
  это дает 
O
(
n
+
n
)
=
O
(
n
)
O( 
n
​
 + 
n
​
 )=O( 
n
​
 ).

5. Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.

Код программы:

python
def binary_search(arr, left, right, target):
    """Вспомогательная функция бинарного поиска"""
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def exponential_search(arr, target):
    n = len(arr)
    if n == 0:
        return -1
    
    # Если элемент в начале массива
    if arr[0] == target:
        return 0
    
    # Экспоненциально увеличиваем границу поиска
    bound = 1
    while bound < n and arr[bound] <= target:
        bound *= 2
    
    # Определяем границы для бинарного поиска
    left = bound // 2
    right = min(bound, n - 1)
    
    # Выполняем бинарный поиск в найденном диапазоне
    return binary_search(arr, left, right, target)

# Пример использования
arr = [2, 3, 4, 10, 15, 18, 20, 22, 25, 30, 40, 45, 50, 60, 70]
target = 18
print(f"Массив: {arr}")
print(f"Поиск элемента {target}: индекс {exponential_search(arr, target)}")
Принцип работы:
Алгоритм начинается с проверки первого элемента массива. Если он не является искомым, алгоритм экспоненциально увеличивает границу поиска (удваивая индекс на каждом шаге), пока не найдет диапазон, где последний элемент превышает или равен целевому значению. Затем в этом диапазоне выполняется бинарный поиск для точного нахождения позиции элемента. Этот подход особенно эффективен для бесконечных массивов или очень больших массивов.

Временная сложность:
O
(
log
⁡
n
)
O(logn)

Объяснение временной сложности:
Экспоненциальное расширение границы требует 
O
(
log
⁡
i
)
O(logi) времени, где 
i
i - позиция искомого элемента. Бинарный поиск в диапазоне размером 
i
i также требует 
O
(
log
⁡
i
)
O(logi) времени. Таким образом, общая сложность составляет 
O
(
log
⁡
i
)
O(logi), что в худшем случае (когда элемент в конце массива) равно 
O
(
log
⁡
n
)
O(logn).

6. Тернарный поиск (Ternary Search)
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции (в зависимости от задачи).

Код программы:
    def ternary_search(arr, target):
        left, right = 0, len(arr) - 1
        
        while left <= right:
            # Вычисляем две точки деления
            mid1 = left + (right - left) // 3
            mid2 = right - (right - left) // 3
            
            # Проверяем, не нашли ли элемент в точках деления
            if arr[mid1] == target:
                return mid1
            if arr[mid2] == target:
                return mid2
            
            # Сужаем диапазон поиска
            if target < arr[mid1]:
                # Искомый элемент в первой трети
                right = mid1 - 1
            elif target > arr[mid2]:
                # Искомый элемент в последней трети
                left = mid2 + 1
            else:
                # Искомый элемент в средней трети
                left = mid1 + 1
                right = mid2 - 1
        
        return -1

# Пример использования
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
target = 7
print(f"Массив: {arr}")
print(f"Поиск элемента {target}: индекс {ternary_search(arr, target)}")
Принцип работы:
Алгоритм делит текущий диапазон поиска на три равные части с помощью двух точек - mid1 и mid2. Сначала проверяются эти точки - если элемент найден в одной из них, поиск завершается. Если нет, определяется в какой из трех частей находится искомый элемент, и поиск рекурсивно продолжается в этой части. Процесс повторяется до тех пор, пока элемент не будет найден или диапазон поиска не станет пустым.

Временная сложность:
O
(
log
⁡
3
n
)
O(log 
3
​
 n)

Объяснение временной сложности:
На каждой итерации алгоритм уменьшает диапазон поиска в 3 раза. Таким образом, максимальное количество итераций равно 
log
⁡
3
n
log 
3
​
 n. Хотя основание логарифма больше, чем в бинарном поиске, количество сравнений на каждой итерации также больше (2 сравнения вместо 1), поэтому на практике бинарный поиск часто оказывается более эффективным.

