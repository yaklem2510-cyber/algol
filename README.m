1. СОРТИРОВКА ВЫБОРОМ (SELECTION SORT)
Код:
'''cpp
#include <iostream>
#include <vector>
using namespace std;

void selectionSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        if (minIndex != i) {
            swap(arr[i], arr[minIndex]);
        }
    }
}

int main() {
    vector<int> arr = {64, 25, 12, 22, 11};
    
    cout << "Исходный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    selectionSort(arr);
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    return 0;
}
'''
Описание работы:
Сортировка выбором - это алгоритм, который на каждом шаге находит минимальный элемент из неотсортированной части массива и помещает его в начало отсортированной части.

Принцип работы:

Внешний цикл проходит по всем элементам массива от первого до предпоследнего

Поиск минимума: для каждой позиции i находим минимальный элемент в оставшейся части массива (от i+1 до конца)

Обмен: меняем местами найденный минимальный элемент с элементом на позиции i

Шаги выполнения для массива [64, 25, 12, 22, 11]:

Шаг 1: Находим мин=11, меняем с 64 → [11, 25, 12, 22, 64]

Шаг 2: Находим мин=12, меняем с 25 → [11, 12, 25, 22, 64]

Шаг 3: Находим мин=22, меняем с 25 → [11, 12, 22, 25, 64]

Шаг 4: Находим мин=25, он уже на месте → [11, 12, 22, 25, 64]

Временная сложность:

Худший случай: O(n²)

Лучший случай: O(n²)

Средний случай: O(n²)

Преимущества: Прост в реализации, минимальное количество обменов
Недостатки: Медленный для больших массивов

2. СОРТИРОВКА ОБМЕНОМ (ПУЗЫРЬКОВАЯ)
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        
        if (!swapped) break;
    }
}

int main() {
    vector<int> arr = {5, 1, 4, 2, 8};
    
    cout << "Исходный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    bubbleSort(arr);
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    return 0;
}
Описание работы:
Пузырьковая сортировка многократно проходит через массив, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

Принцип работы:

Внешний цикл определяет количество проходов

Внутренний цикл сравнивает соседние элементы

Обмен происходит, если левый элемент больше правого

Оптимизация: если за проход не было обменов, массив отсортирован

Процесс для массива [5, 1, 4, 2, 8]:

Проход 1: 1↔5, 4↔5, 2↔5 → [1, 4, 2, 5, 8]

Проход 2: 2↔4 → [1, 2, 4, 5, 8]

Проход 3: нет обменов → завершение

Временная сложность:

Худший случай: O(n²)

Лучший случай: O(n) (уже отсортирован)

Средний случай: O(n²)

Преимущества: Прост в реализации, стабильная сортировка
Недостатки: Очень медленный для больших массивов

3. СОРТИРОВКА ВСТАВКАМИ
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

void insertionSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
}

int main() {
    vector<int> arr = {12, 11, 13, 5, 6};
    
    cout << "Исходный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    insertionSort(arr);
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    return 0;
}
Описание работы:
Сортировка вставками строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию.

Принцип работы:

Начинаем со второго элемента (i=1)

Сохраняем текущий элемент как key

Сдвигаем элементы большие key вправо

Вставляем key на освободившуюся позицию

Процесс для массива [12, 11, 13, 5, 6]:

i=1: key=11 → [11, 12, 13, 5, 6]

i=2: key=13 → [11, 12, 13, 5, 6]

i=3: key=5 → [5, 11, 12, 13, 6]

i=4: key=6 → [5, 6, 11, 12, 13]

Временная сложность:

Худший случай: O(n²)

Лучший случай: O(n) (уже отсортирован)

Средний случай: O(n²)

Преимущества: Эффективен для небольших массивов, стабильный, адаптивный
Недостатки: Медленный для больших массивов

4. СОРТИРОВКА СЛИЯНИЕМ
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    vector<int> L(n1), R(n2);
    
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
    
    int i = 0, j = 0, k = left;
    
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    while (i < n1) {
        arr[k] = L[i];
        i++; k++;
    }
    
    while (j < n2) {
        arr[k] = R[j];
        j++; k++;
    }
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

int main() {
    vector<int> arr = {38, 27, 43, 3, 9, 82, 10};
    
    cout << "Исходный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    mergeSort(arr, 0, arr.size() - 1);
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    return 0;
}
Описание работы:
Сортировка слиянием использует стратегию "разделяй и властвуй". Массив рекурсивно делится пополам до отдельных элементов, затем сливается обратно в отсортированном порядке.

Принцип работы:

Разделение: массив делится пополам рекурсивно

Слияние: два отсортированных подмассива сливаются в один отсортированный

Процесс для массива [38, 27, 43, 3, 9, 82, 10]:

Делим: [38,27,43,3] и [9,82,10]

Делим: [38,27], [43,3], [9,82], [10]

Делим до отдельных элементов

Сливаем: [27,38], [3,43], [9,82], [10]

Сливаем: [3,27,38,43], [9,10,82]

Сливаем: [3,9,10,27,38,43,82]

Временная сложность:

Худший случай: O(n log n)

Лучший случай: O(n log n)

Средний случай: O(n log n)

Память: O(n)

Преимущества: Стабильная, предсказуемое время выполнения
Недостатки: Требует дополнительной памяти

5. СОРТИРОВКА ШЕЛЛА
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

void shellSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j;
            
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            
            arr[j] = temp;
        }
    }
}

int main() {
    vector<int> arr = {12, 34, 54, 2, 3};
    
    cout << "Исходный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    shellSort(arr);
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    return 0;
}
Описание работы:
Сортировка Шелла - это улучшенная версия сортировки вставками. Она сортирует элементы, расположенные далеко друг от друга, постепенно уменьшая расстояние между сравниваемыми элементами.

Принцип работы:

Последовательность промежутков: начинаем с большого gap (n/2), уменьшаем вдвое

Сортировка вставками для каждого gap

При gap=1 превращается в обычную сортировку вставками

Процесс для массива [12, 34, 54, 2, 3]:

gap=2: сравниваем и сортируем элементы с шагом 2

gap=1: окончательная сортировка вставками

Временная сложность:

Зависит от последовательности gap

Худший случай: O(n²)

Лучший случай: O(n log n)

Средний случай: O(n^(3/2))

Преимущества: Эффективнее сортировки вставками, мало дополнительной памяти
Недостатки: Сложность зависит от выбора последовательности gap

6. БЫСТРАЯ СОРТИРОВКА
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    vector<int> arr = {10, 7, 8, 9, 1, 5};
    
    cout << "Исходный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    quickSort(arr, 0, arr.size() - 1);
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    return 0;
}
Описание работы:
Быстрая сортировка использует стратегию "разделяй и властвуй". Выбирается опорный элемент, массив разделяется на элементы меньше опорного и больше опорного, затем рекурсивно сортируются подмассивы.

Принцип работы:

Выбор опорного элемента (в данном случае последний)

Разделение: перераспределение элементов относительно опорного

Рекурсия: сортировка левого и правого подмассивов

Процесс для массива [10, 7, 8, 9, 1, 5]:

Опорный=5 → [1, 5, 8, 9, 10, 7]

Левая часть [1], правая [8,9,10,7]

Сортируем правую: опорный=7 → [7,9,10,8]

И т.д.

Временная сложность:

Худший случай: O(n²) (уже отсортирован)

Лучший случай: O(n log n)

Средний случай: O(n log n)

Преимущества: Очень быстрый на практике, мало дополнительной памяти
Недостатки: Нестабильный, худший случай O(n²)

7. ПИРАМИДАЛЬНАЯ СОРТИРОВКА
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest])
        largest = left;
    
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    
    cout << "Исходный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    heapSort(arr);
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    return 0;
}
Описание работы:
Пирамидальная сортировка использует структуру данных "двочная куча". Сначала строится max-heap, затем максимальный элемент перемещается в конец, и куча перестраивается.

Принцип работы:

Построение кучи: преобразование массива в max-heap

Извлечение максимума: перемещение корня в конец

Восстановление кучи: перестройка кучи для оставшихся элементов

Процесс:

Строим max-heap из массива

Меняем корень с последним элементом

Уменьшаем размер кучи, восстанавливаем свойства

Повторяем пока куча не пуста

Временная сложность:

Худший случай: O(n log n)

Лучший случай: O(n log n)

Средний случай: O(n log n)

Преимущества: Всегда O(n log n), не требует дополнительной памяти
Недостатки: Нестабильный, медленнее быстрой сортировки на практике

8. ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

int sequentialSearch(const vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}

int main() {
    vector<int> arr = {2, 5, 8, 12, 16, 23, 38, 45, 67, 89};
    int target = 23;
    
    cout << "Массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    int result = sequentialSearch(arr, target);
    
    if (result != -1) {
        cout << "Элемент " << target << " найден на позиции " << result << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
    
    return 0;
}
Описание работы:
Последовательный поиск - простейший алгоритм поиска, который проверяет каждый элемент массива последовательно до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

Принцип работы:

Начинаем с первого элемента массива

Сравниваем текущий элемент с искомым значением

Если совпадает - возвращаем индекс

Если нет - переходим к следующему элементу

Если дошли до конца - возвращаем -1

Временная сложность:

Худший случай: O(n) - элемент в конце или отсутствует

Лучший случай: O(1) - элемент первый

Средний случай: O(n)

Преимущества: Прост в реализации, работает на неотсортированных массивах
Недостатки: Медленный для больших массивов

9. БИНАРНЫЙ ПОИСК
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

int binarySearch(const vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

int main() {
    vector<int> arr = {2, 5, 8, 12, 16, 23, 38, 45, 67, 89};
    int target = 23;
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    int result = binarySearch(arr, target);
    
    if (result != -1) {
        cout << "Элемент " << target << " найден на позиции " << result << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
    
    return 0;
}
Описание работы:
Бинарный поиск работает только на отсортированных массивах. На каждом шаге алгоритм сравнивает искомое значение со средним элементом текущего диапазона и исключает половину элементов из рассмотрения.

Принцип работы:

Определяем левую и правую границы поиска

Находим средний элемент

Сравниваем с искомым значением

Если совпадает - возвращаем индекс

Если искомое больше - ищем в правой половине

Если искомое меньше - ищем в левой половине

Повторяем пока границы не сойдутся

Пример поиска 23 в [2,5,8,12,16,23,38,45,67,89]:

Шаг 1: mid=16, 23>16 → ищем справа

Шаг 2: mid=38, 23<38 → ищем слева

Шаг 3: mid=23 → найдено

Временная сложность:

Худший случай: O(log n)

Лучший случай: O(1)

Средний случай: O(log n)

Преимущества: Очень быстрый, эффективное использование памяти
Недостатки: Требует отсортированного массива

10. ИНТЕРПОЛИРУЮЩИЙ ПОИСК
Код:
cpp
#include <iostream>
#include <vector>
using namespace std;

int interpolationSearch(const vector<int>& arr, int target) {
    int low = 0;
    int high = arr.size() - 1;
    
    while (low <= high && target >= arr[low] && target <= arr[high]) {
        if (low == high) {
            if (arr[low] == target) return low;
            return -1;
        }
        
        int pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]);
        
        if (arr[pos] == target) {
            return pos;
        } else if (arr[pos] < target) {
            low = pos + 1;
        } else {
            high = pos - 1;
        }
    }
    
    return -1;
}

int main() {
    vector<int> arr = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    int target = 50;
    
    cout << "Равномерно распределенный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    int result = interpolationSearch(arr, target);
    
    if (result != -1) {
        cout << "Элемент " << target << " найден на позиции " << result << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
    
    return 0;
}
Описание работы:
Интерполирующий поиск - улучшение бинарного поиска для равномерно распределенных данных. Вместо деления пополам, вычисляет вероятную позицию элемента используя интерполяционную формулу.

Формула интерполяции:

text
pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])
Принцип работы:

Вычисляем предполагаемую позицию по формуле интерполяции

Сравниваем элемент на этой позиции с искомым

Если совпадает - возвращаем позицию

Если искомое больше - ищем справа

Если искомое меньше - ищем слева

Временная сложность:

Худший случай: O(n) (неравномерное распределение)

Лучший случай: O(1)

Средний случай: O(log log n) для равномерного распределения

Преимущества: Очень быстрый для равномерно распределенных данных
Недостажки: Медленный для неравномерных данных, сложнее реализации

11. ПОИСК ФИБОНАЧЧИ
Код:
cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int fibonacciSearch(const vector<int>& arr, int target) {
    int n = arr.size();
    
    int fib2 = 0;
    int fib1 = 1;
    int fib = fib1 + fib2;
    
    while (fib < n) {
        fib2 = fib1;
        fib1 = fib;
        fib = fib1 + fib2;
    }
    
    int offset = -1;
    
    while (fib > 1) {
        int i = min(offset + fib2, n - 1);
        
        if (arr[i] < target) {
            fib = fib1;
            fib1 = fib2;
            fib2 = fib - fib1;
            offset = i;
        } else if (arr[i] > target) {
            fib = fib2;
            fib1 = fib1 - fib2;
            fib2 = fib - fib1;
        } else {
            return i;
        }
    }
    
    if (fib1 && offset + 1 < n && arr[offset + 1] == target) {
        return offset + 1;
    }
    
    return -1;
}

int main() {
    vector<int> arr = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
    int target = 85;
    
    cout << "Отсортированный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    int result = fibonacciSearch(arr, target);
    
    if (result != -1) {
        cout << "Элемент " << target << " найден на позиции " << result << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
    
    return 0;
}
Описание работы:
Поиск Фибоначчи использует числа Фибоначчи для разделения массива. Основан на том, что любое число можно представить как сумму чисел Фибоначчи.

Принцип работы:

Находим наименьшее число Фибоначчи, большее или равное размеру массива

Используем числа Фибоначчи для определения позиций сравнения

Сравниваем элемент с искомым значением

В зависимости от сравнения, сужаем диапазон поиска

Преимущества использования чисел Фибоначчи:

Избегает дорогостоящего деления

Эффективен в системах где деление дорого

Временная сложность:

Худший случай: O(log n)

Лучший случай: O(1)

Средний случай: O(log n)

Преимущества: Эффективен когда деление дорого, предсказуемая производительность
Недостатки: Сложнее реализации, не всегда быстрее бинарного поиска

СВОДНАЯ ТАБЛИЦА ЭФФЕКТИВНОСТИ
Алгоритмы сортировки:
Алгоритм	Лучший	Средний	Худший	Память	Стабильность
Выбором	O(n²)	O(n²)	O(n²)	O(1)	Нет
Пузырьковая	O(n)	O(n²)	O(n²)	O(1)	Да
Вставками	O(n)	O(n²)	O(n²)	O(1)	Да
Слиянием	O(n log n)	O(n log n)	O(n log n)	O(n)	Да
Шелла	O(n log n)	O(n^(3/2))	O(n²)	O(1)	Нет
Быстрая	O(n log n)	O(n log n)	O(n²)	O(log n)	Нет
Пирамидальная	O(n log n)	O(n log n)	O(n log n)	O(1)	Нет
Алгоритмы поиска:
Алгоритм	Лучший	Средний	Худший	Условия
Последовательный	O(1)	O(n)	O(n)	Любой массив
Бинарный	O(1)	O(log n)	O(log n)	Отсортированный
Интерполирующий	O(1)	O(log log n)	O(n)	Равномерное распределение
Фибоначчи	O(1)	O(log n)	O(log n)	Отсортированный
ВЫВОДЫ
Для небольших массивов (n < 50): сортировка вставками или выбором

Для средних массивов (50 < n < 1000): быстрая сортировка или Шелла

Для больших массивов (n > 1000): быстрая, пирамидальная или слиянием

Когда важна стабильность: слиянием или вставками

Когда память ограничена: пирамидальная или Шелла

Для поиска в отсортированных массивах: бинарный поиск

Для равномерно распределенных данных: интерполирующий поиск

Все представленные алгоритмы являются фундаментальными и широко используются в компьютерных науках и промышленном программировании.

