Исследование алгоритмов сортировки и поиска на языках программирования C++, Python, Java
(Автор: Клементьев Ярослав, группа УИБО-10-24)

Алгоритмы сортировки
1. Сортировка выбором (Selection Sort)
Определение:
Алгоритм сортировки выбором на каждом шаге находит минимальный элемент в оставшейся части массива и обменивает его с текущим элементом.

Принцип работы:

Внешний цикл последовательно проходит по элементам массива.

Внутренний цикл находит минимальный элемент среди оставшихся.

Производится обмен найденного минимального элемента с текущим.

Результат выполнения кода:
Отсортированный массив: [11, 12, 22, 25, 64]

Временная сложность:
O(n²), где n — количество элементов.

2. Сортировка пузырьком (Bubble Sort)
Определение:
Алгоритм многократно проходит по списку, сравнивая соседние элементы и меняя их местами при необходимости.

Принцип работы:

Внешний цикл выполняет n проходов по массиву.

Внутренний цикл попарно сравнивает элементы.

Возможна досрочная остановка при отсутствии обменов.

Результат выполнения кода:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

Временная сложность:
O(n²), с оптимизацией для почти отсортированных массивов — O(n).

3. Сортировка вставками (Insertion Sort)
Определение:
Алгоритм последовательно строит отсортированную часть массива, вставляя каждый новый элемент в нужную позицию.

Принцип работы:

Начинается со второго элемента массива.

Каждый новый элемент сравнивается с предыдущими.

Элементы большие ключа сдвигаются вправо.

Результат выполнения кода:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

Временная сложность:
O(n²), для почти отсортированных данных — O(n).

4. Сортировка слиянием (Merge Sort)
Определение:
Алгоритм разделяет массив на части, сортирует их и объединяет результаты.

Принцип работы:

Рекурсивное разделение массива пополам.

Сортировка каждой половины.

Слияние отсортированных частей.

Результат выполнения кода:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]

Временная сложность:
O(n log n).

5. Сортировка Шелла (Shell Sort)
Определение:
Усовершенствованная версия сортировки вставками с использованием переменного шага.

Принцип работы:

Сортировка элементов с определенным шагом.

Постепенное уменьшение шага до 1.

Результат выполнения кода:
Отсортированный массив: [2, 3, 12, 34, 54]

Временная сложность:
В среднем O(n^1.25).

6. Быстрая сортировка (Quick Sort)
Определение:
Эффективный алгоритм, использующий стратегию "разделяй и властвуй" с выбором опорного элемента.

Принцип работы:

Выбор опорного элемента.

Разделение массива на элементы меньше и больше опорного.

Рекурсивная сортировка частей.

Результат выполнения кода:
Отсортированный массив: [1, 5, 7, 8, 9, 10]

Временная сложность:
В среднем O(n log n), в худшем случае O(n²).

7. Пирамидальная сортировка (Heap Sort)
Определение:
Алгоритм, использующий структуру двоичной кучи для сортировки.

Принцип работы:

Построение двоичной кучи.

Последовательное извлечение максимальных элементов.

Перестроение кучи после каждого извлечения.

Результат выполнения кода:
Отсортированный массив: [5, 6, 7, 11, 12, 13]

Временная сложность:
O(n log n).

Алгоритмы поиска
1. Линейный поиск (Linear Search)
Определение:
Последовательная проверка каждого элемента массива до нахождения искомого.

Принцип работы:

Поочередное сравнение элементов с искомым значением.

Завершение при нахождении элемента или конце массива.

Результат выполнения кода:
Элемент найден на позиции: 3

Временная сложность:
O(n).

2. Бинарный поиск (Binary Search)
Определение:
Поиск в отсортированном массиве путем деления области поиска пополам.

Принцип работы:

Определение среднего элемента.

Сравнение с искомым значением.

Сужение области поиска.

Результат выполнения кода:
Элемент найден на позиции: 3

Временная сложность:
O(log n).

3. Интерполяционный поиск (Interpolation Search)
Определение:
Улучшенный алгоритм поиска для равномерно распределенных данных.

Принцип работы:

Оценка позиции искомого элемента на основе распределения значений.

Адаптивное определение области поиска.

Результат выполнения кода:
Элемент найден на позиции: 4

Временная сложность:
O(log log n) при равномерном распределении, O(n) в худшем случае.

4. Поиск Фибоначчи (Fibonacci Search)
Определение:
Алгоритм поиска, использующий числа Фибоначчи для определения позиций сравнения.

Принцип работы:

Использование последовательности Фибоначчи для деления массива.

Поэтапное сужение области поиска.

Результат выполнения кода:
Элемент найден на позиции: 8

Временная сложность:
O(log n).

Итоговые выводы
На основании анализа алгоритмов сортировки и поиска можно сделать следующие заключения:

Наиболее производительные алгоритмы сортировки основаны на принципе "разделяй и властвуй": быстрая сортировка и сортировка слиянием, демонстрирующие среднюю сложность O(N⋅logN). Они оптимальны для работы с крупными наборами данных.

Простые методы сортировки (выбором, вставками, пузырьком) имеют сложность O(N²) и эффективны только для небольших массивов или в учебных целях.

Среди алгоритмов поиска наибольшую эффективность показывает бинарный поиск (O(logN)), требующий предварительной сортировки данных. Линейный поиск (O(N)) применим для небольших коллекций или когда сортировка невозможна.

Специализированные алгоритмы поиска (интерполяционный и Фибоначчи) демонстрируют улучшенную производительность на данных с определенными характеристиками распределения.

Заключение: Выбор оптимального алгоритма зависит от конкретных условий задачи — объема данных, требований к производительности и характеристик исходной информации. Для крупных наборов данных предпочтительны эффективные алгоритмы, для небольших коллекций или специфических случаев достаточно простых методов.



