Задание 6: Деревья и графы (Клементьев Ярослав, УИБО-10-24)
Вариант 16
"Реализуйте три вида обхода бинарного дерева (preorder, inorder, postorder)."

Реализация трех видов обхода бинарного дерева (Preorder, Inorder, Postorder)

Java реализация

Алгоритм Java:

Preorder: проверка на null, вывод корня, рекурсивный вызов для левого поддерева, рекурсивный вызов для правого поддерева.

Inorder: проверка на null, рекурсивный вызов для левого поддерева, вывод корня, рекурсивный вызов для правого поддерева.

Postorder: проверка на null, рекурсивный вызов для левого поддерева, рекурсивный вызов для правого поддерева, вывод корня.

Сложность Java: O(n). Обусловлено тем, что каждый узел обрабатывается один раз, что гарантирует линейное время выполнения.

C++ реализация

Алгоритм C++:

Preorder: проверка на nullptr, вывод корня, рекурсивный вызов для левого поддерева, рекурсивный вызов для правого поддерева.

Inorder: проверка на nullptr, рекурсивный вызов для левого поддерева, вывод корня, рекурсивный вызов для правого поддерева.

Postorder: проверка на nullptr, рекурсивный вызов для левого поддерева, рекурсивный вызов для правого поддерева, вывод корня.

Сложность C++: O(n). Обусловлено тем, что все узлы посещаются ровно один раз, что обеспечивает линейную сложность.

Python реализация

Алгоритм Python:

Preorder: проверка на None, вывод корня, рекурсивный вызов для левого поддерева, рекурсивный вызов для правого поддерева.

Inorder: проверка на None, рекурсивный вызов для левого поддерева, вывод корня, рекурсивный вызов для правого поддерева.

Postorder: проверка на None, рекурсивный вызов для левого поддерева, рекурсивный вызов для правого поддерева, вывод корня.

Сложность Python: O(n). Обусловлено тем, что алгоритм посещает каждый узел ровно один раз, что приводит к линейной зависимости от числа узлов.

Объяснение временной сложности
Во всех реализациях используется рекурсивный обход в глубину (DFS).

O(n): алгоритм проходит каждый узел дерева ровно один раз, где n — общее количество узлов.

Почему? Для каждого узла выполняется проверка на наличие потомков, и рекурсия продолжается для не-null потомков. Это исключает повторные обработки узлов.

Базовый случай (узел равен null/None) гарантирует завершение рекурсии.

Каждый узел обрабатывается за постоянное время O(1), общее время пропорционально количеству узлов n.

Контрольные вопросы 5

Суть стратегии «разделяй и властвуй»
Стратегия «разделяй и властвуй» (Divide and Conquer) — это фундаментальный парадигматический подход к решению сложных задач, который состоит из трех последовательных этапов:

Разделение (Divide) - исходная задача разбивается на несколько меньших подзадач того же типа

Властвование (Conquer) - подзадачи решаются рекурсивно

Комбинирование (Combine) - решения подзадач объединяются в решение исходной задачи

Реализация в сортировке слиянием
Стратегия «разделяй и властвуй» в сортировке слиянием демонстрирует свою мощь, превращая задачу сортировки со сложностью O(n²) в эффективный алгоритм с сложностью O(n log n). Этот подход не только обеспечивает оптимальную производительность, но и представляет элегантное решение, где сложная проблема последовательно разбивается на простые подзадачи, которые затем комбинируются в окончательное решение.

Ключевая идея стратегии — «разделяй проблему, властвуй над частями, объединяй решения» — делает ее универсальным инструментом для решения широкого класса алгоритмических задач.
